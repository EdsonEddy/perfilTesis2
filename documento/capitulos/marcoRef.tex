\chapter{MARCO REFERENCIAL}

\section{Introducción}
\cite{unknown1} Explica que la identificación de similitud entre códigos fuente puede servir para varios propósitos, entre ellos están el estudio de la evolución de código fuente de un proyecto, detección de prácticas de plagio, detección de prácticas de reutilización, extracción de código para “refactorización” del mismo y seguimiento de defectos para su corrección.

Un estudiante de programacion durante su proceso de formacion, realiza trabajos, proyectos, tareas y  ejercicios de programacion, estas actividades ayudan a desarrollar la capacidad de resolucion de problemas, enfoque logico y otros. Cuando la presentacion de estas actividades es individual, encontrar trabajos similares presentados por estudiantes puede ser considerado como plagio. Una de las formas para detectar la similitud en trabajos de programación consiste en realizar la comparación entre los trabajos entregados por los estudiantes de la materia. De a modo de obtener una lista de estudiantes que tienen trabajos similares. Realizar la comparación de los trabajos manualmente puede llegar a ser un trabajo moroso.

En la actualidad existen diferentes herramientas de software que aplican metodos para la deteccion de similitud entre codigos fuente, apartir de las caracteristicas de estas herramientas se puede evidenciar que presentan deficiencias como la obsolescencia, sistemas sin codigo abierto, procesos complejos de evaluacion de similitud, sistemas incapaces que detectar similitud en un grupo grande de archivos de codigo fuente.

Ademas \cite{Novak2019} hace mención a que los enfoques basados en estructuras son mucho mejores, ademas que la mayoría de las herramientas de detección de similitud combinan más de un tipo de algoritmo. El diseño del algoritmo propuesto contara con tres fases, la primera fase consiste en la conversion de codigo fuente en arbol de sintaxis abstracta AST, esto se realizara mediante conceptos de compiladores, la segunda fase consiste en la comparacion de arboles obtenidos mediante conceptos de distancia de edicion de arboles TED, la fase final consiste en la agrupacion de codigos similires mediante conceptos de estructuras para conjuntos disjuntos DSU.

En el presente trabajo de tesis se centra en el diseño e implementacion de un algoritmo para la deteccion de similitud entre codigos fuente que tenga buen desempeño, en terminos de tiempo de ejecucion, espacio de memoria ocupado y precision.

\section{Problema}
\subsection{Antecedentes del problema}
Se analizaron herramientas para la detección de similitud entre código fuente más populares, a continuación se dará breve explicación de las características que tienen estas.
\subsubsection{Sherlock}
Es una herramienta de código abierto, que trabaja con código escrito en los lenguajes Java, C y texto natural. Esta herramienta no cuenta con una interfaz gráfica. Fue desarrollada por la Universidad de Sydney. Los resultados arrojados se basan en un porcentaje que se corresponde con las similitudes encontradas. El porcentaje 0\% significa que no hay similitudes, y 100\% significa que hay muchas posibilidades de que tengan partes iguales. Al no utilizar el documento en su totalidad, no se puede afirmar que sean completamente iguales. Sólo trabaja con archivos locales, no busca similitudes en Internet \cite{article1}.
\subsubsection{Simian}
Esta herramienta no es de código abierto. Identifica la duplicación de códigos escritos en JAVA, C, C++, COBOL, Ruby, JSP, ASP, HTML, XML, Visual Basic y texto natural. Fue desarrollada por una consultora de Australia llamada REDHILL. No cuenta con una interfaz gráfica, por lo tanto, el ingreso de los parámetros es a través de línea de comando. Sólo trabaja con archivos locales, no busca similitudes en Internet \cite{article1}.
\subsubsection{Jplag}
Esta herramienta no es de código abierto, sólo permite la programación del cliente, pero el servidor es el que realiza las operaciones de comparación; se encuentra en la Universidad de Karlsruhe de Alemania, en la cual fue desarrollada. Trabaja con los siguientes lenguajes C, C++, Java, Scheme y texto natural. Fue desarrollada por la Universidad de Karlsruhe de Alemania. Analiza la estructura y sintaxis del código, no comparando texto. Este sistema sólo trabaja con archivos locales, no busca similitudes en Internet. Su arquitectura de trabajo es Cliente/Servidor. La interfaz es a través de línea de comando, o, puede implementarse un cliente propio. Para el manejo de los archivos enviados, puede utilizarse el cliente brindado por la universidad que lo desarrolló o bien crear un cliente propio, como mencionamos anteriormente \cite{article1}.
\subsubsection{Tester SIM}
Es una herramienta de código abierto. Trabaja con los lenguajes C, JAVA, Lisp, Modula 2, Pascal y texto natural. Está desarrollada por la Universidad de Amsterdam. No cuenta con una interfaz gráfica, se ingresan los distintos parámetros por línea de comando. Los resultados brindados por la misma aparecen separados en dos columnas, mostrando en cada una las porciones de código iguales. Sólo trabaja con búsquedas de similitudes en archivos locales. También se puede procesar un conjunto de archivos viejos contra un conjunto de archivos nuevos  \cite{article1}.
\subsubsection{MOSS}
Software creado por el profesor Alex Aiken en la universidad de Stanford, es el primer servicio que inició en la web, siendo una referencia a nivel mundial. Este, permite comparar hasta 250 archivos en 25 lenguajes de programación \cite{Hage2010ACO}. Aunque no tiene licencia como software libre, su uso dentro del ambiente académico es gratuito y ofrecido desde un servidor de Stanford. Es de difícil su configuración y tiene poca documentación \cite{book1}.
\subsection{Planteamiento del problema}
Los estudiantes de programación durante su proceso de formación elaboran trabajos, proyectos, tareas, ejercicios, etc. de programación, escritos en algún lenguaje de programación. Estas actividades deben realizarse de forma individual dado que sirven para medir la capacidad de resolución de problemas y el enfoque lógico de los estudiantes. Por ello encontrar similitud en trabajos de programación presentados por estudiantes puede ser identificado como plagio de código fuente.

La forma mas simple para detectar plagio en trabajos de programación, consiste en realizar la comparación de forma manual entre todos los trabajos presentados, de modo de obtener una lista de estudiantes que tienen trabajos similares. Realizar esta comparación llega a ser una trabajo moroso, por lo cual contar con una herramienta de software que realice las comparaciones de forma automática y genere la una lista de trabajos similares es de gran utilidad.

En la actualidad existen herramientas de software para detectar similitud entre códigos fuente. Según sus características se observo que estas presentan deficiencias como la obsolescencia, sin código abierto, incapacidad de utilizar gran base de información.
\subsection{Formulación del problema}
¿El algoritmo JTEL tiene mejor desempeño frente a otras herramientas en la detección de similitud de códigos fuente en trabajos de cátedra?

\section{Objetivos}
\subsection{Objetivo general}
Diseñar e implementar el algoritmo JTEL para la detección de similitud entre códigos fuente.
\subsection{Objetivos específicos}
\begin{itemize}
    \item Estudiar los métodos para la detección de similitud entre códigos fuente existentes.
    \item Estudiar los algoritmos utilizados en los métodos para la detección de similitud de código fuente.
    \item Redactar las especificaciones para el algoritmo JTEL.
    \item Evaluar el desempeño del algoritmo JTEL realizando las pruebas en trabajos de programación presentado por estudiantes.
\end{itemize}

\section{Hipótesis}
El algoritmo JTEL implementado para la detección de similitud entre códigos fuente obtiene mejores resultados frente a otras herramientas para la detección de similitud.
\subsection{Variables Independientes}
\begin{itemize}
    \item El algoritmo JTEL para la detección de similitud entre códigos fuente.
\end{itemize}
\subsection{Variables Dependientes}
\begin{itemize}
    \item Resultados más precisos respecto a la detección de similitud entre códigos fuente de trabajos de cátedra frente a otras herramientas.
\end{itemize}
\section{Justificaciones}
\subsection{Justificación Social}
El algoritmo JTEL ahorrará el tiempo de docentes de instituciones académicas en la detección de plagio en trabajos de programación presentados por estudiantes, evitando que los docentes realicen la comparación de trabajos de programación de forma manual.
\subsection{Justificación Económica}
El algoritmo JTEL para la detección de similitud entre códigos fuente sera de código abierto, por lo cual permitirá que se desarrollen otros software a bajo costo.
\subsection{Justificación Tecnológica}
El algoritmo JTEL para la detección de similitud entre códigos fuente, se puede implementar en jueces de programación para identificar los envíos similares de los usuarios del juez.
\subsection{Justificación Científica}
Con la utilización de trabajos de programación presentados por estudiantes se medirá el desempeño de los métodos existentes para la detección de similitud entre códigos fuente. Con los resultados obtenidos se determinará cuál es el método más eficiente en términos de tiempo de ejecución, espacio de memoria ocupado y precisión.
\section{Alcances y Limites}
\subsection{Alcance Sustancial}
\begin{itemize}
    \item Se diseñará e implementará en Python un algoritmo JTEL para la detección de similitud entre códigos fuente.
    \item Se realizaran las pruebas de trabajos de cátedra de código fuente en Python.
    \item Se dejará de lado la comprobación de correctitud de los códigos fuente.
    \item Se realizarán pruebas para medir el tiempo, espacio de memoria ocupado y eficiencia del algoritmo.
    \item Se dejará de lado el estudio de métodos para la detección de similitud que aplican técnicas de Inteligencia Artificial.
\end{itemize}
\subsection{Alcance Espacial}
\begin{itemize}
    \item Se realizaran las pruebas del algoritmo en una computadora intel i3 de Décima generación con 8GB de RAM y 512GB de Disco Duro.
\end{itemize}
\subsection{Alcance Temporal}
\begin{itemize}
    \item El tiempo de ejecución que el algoritmo estará limitado a un minuto. Por cada conjunto de trabajos evaluados.
\end{itemize}
\section{Metodología}
\subsection{Metodología Experimental}
Para el desarrollo del trabajo de investigación se utilizara la metodología científica experimental, esta investigación
nos permite la manipulación de una o mas variables. De modo que al seguir las siguientes etapas ayudara a cumplir con los objetivos propuestos.
\begin{enumerate}
  \item \textbf{Recopilación de la información.} En esta etapa se recopilara información necesaria y estudiara los temas.
  \item \textbf{Diseño del algoritmo.} En esta etapa se diseñara el algoritmo tomando en cuenta los alcances y limites.
  \item \textbf{Pruebas de funcionamiento del algoritmo en trabajos de cátedra.} En esta etapa se Realizara pruebas en trabajos de cátedra presentados por estudiantes.
  \item \textbf{Análisis de los resultados obtenidos.} En esta etapa se analizaran los datos y se los comparara frente a otras herramientas.
  \item \textbf{Conclusiones.} En esta etapa se realizara las conclusiones, se presentaran los resultados finales, y recomendaciones respecto a la investigación.
\end{enumerate}
